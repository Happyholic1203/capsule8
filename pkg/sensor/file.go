// Copyright 2017 Capsule8, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sensor

import (
	"fmt"
	"path/filepath"
	"strings"
	"sync"
	"sync/atomic"

	"github.com/Happyholic1203/capsule8/pkg/expression"
	"github.com/Happyholic1203/capsule8/pkg/sys/perf"
	"github.com/golang/glog"
)

// FileCreateEventTypes defines the field types that can be used with filters
// on file create telemetry events.
var FileCreateEventTypes = expression.FieldTypeMap{
	"filename": expression.ValueTypeString,
	"mode":     expression.ValueTypeSignedInt32,
}

// FileDeleteEventTypes defines the field types that can be used with filters
// on file delete telemetry events.
var FileDeleteEventTypes = expression.FieldTypeMap{
	"filename": expression.ValueTypeString,
}

// FileLinkEventTypes defines the field types that can be used with filters
// on the file link telemetry events.
var FileLinkEventTypes = expression.FieldTypeMap{
	"source_file": expression.ValueTypeString,
	"target_file": expression.ValueTypeString,
	"symlink":     expression.ValueTypeBool,
}

// FileOpenForModifyEventTypes defines the field types that can be used with filters
// on file open for modify telemetry events.
var FileOpenForModifyEventTypes = expression.FieldTypeMap{
	"filename": expression.ValueTypeString,
}

// FileCloseForModifyEventTypes defines the field types that can be used with filters
// on file close for modify telemetry events.
var FileCloseForModifyEventTypes = expression.FieldTypeMap{
	"filename": expression.ValueTypeString,
}

// FileModifyEventTypes defines the field types that can be used with filters
// on file modify telemetry events.
var FileModifyEventTypes = expression.FieldTypeMap{
	"filename": expression.ValueTypeString,
}

// FileOpenEventTypes defines the field types that can be used with filters
// on file open telemetry events.
var FileOpenEventTypes = expression.FieldTypeMap{
	"filename": expression.ValueTypeString,
	"flags":    expression.ValueTypeSignedInt32,
	"mode":     expression.ValueTypeSignedInt32,
}

// FileRenameEventTypes defines the field types that can be used with filters
// on file rename telemetry events.
var FileRenameEventTypes = expression.FieldTypeMap{
	"oldname": expression.ValueTypeString,
	"newname": expression.ValueTypeString,
}

// FileAttributeChangeEventTypes defines the field types that can be used with filters
// on file rename telemetry events.
var FileAttributeChangeEventTypes = expression.FieldTypeMap{
	"filename": expression.ValueTypeString,
}

// FileCreateTelemetryEvent is a telemetry event generated by the file event
// source.
type FileCreateTelemetryEvent struct {
	TelemetryEventData

	Filename string
	Mode     int32
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file create telemetry event.
func (e FileCreateTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// FileDeleteTelemetryEvent is a telemetry event generated by the file event
// source.
type FileDeleteTelemetryEvent struct {
	TelemetryEventData

	Filename string
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file delete telemetry event.
func (e FileDeleteTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// FileLinkTelemetryEvent is a telemetry event generated by the file event
// source.
type FileLinkTelemetryEvent struct {
	TelemetryEventData

	SourceFile string
	TargetFile string
	Symlink    bool
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file link telemetry event.
func (e FileLinkTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// FileModifyTelemetryEvent is a telemetry event generated by the file event
// source.
type FileModifyTelemetryEvent struct {
	TelemetryEventData

	Filename string
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file modify telemetry event.
func (e FileModifyTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// FileOpenTelemetryEvent is a telemetry event generated by the file event
// source.
type FileOpenTelemetryEvent struct {
	TelemetryEventData

	Filename string
	Flags    int32
	Mode     int32
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file open telemetry event.
func (e FileOpenTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// FileRenameTelemetryEvent is a telemetry event generated by the file event
// source.
type FileRenameTelemetryEvent struct {
	TelemetryEventData

	Oldname string
	Newname string
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file rename telemetry event.
func (e FileRenameTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// FileOpenForModifyTelemetryEvent is a telemetry event generated by the file event
// source.
type FileOpenForModifyTelemetryEvent struct {
	TelemetryEventData

	Filename string
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file modify telemetry event.
func (e FileOpenForModifyTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// FileCloseForModifyTelemetryEvent is a telemetry event generated by the file event
// source.
type FileCloseForModifyTelemetryEvent struct {
	TelemetryEventData

	Filename string
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file modify telemetry event.
func (e FileCloseForModifyTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// FileAttributeChangeTelemetryEvent is a telemetry event generated by the file
// attribute change event source.
type FileAttributeChangeTelemetryEvent struct {
	TelemetryEventData

	Filename string
}

// CommonTelemetryEventData returns the telemetry event data common to all
// telemetry events for a file modify telemetry event.
func (e FileAttributeChangeTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

const (
	fsDoSysOpenKprobeAddress   = "do_sys_open"
	fsDoSysOpenKprobeFetchargs = "filename=+0(%si):string flags=%dx:s32 mode=%cx:s32"

	fetchArgMaxLength                 = 63
	dentryArgBaseOverhead             = 14
	dentryArgMinimumComponentOverhead = 4

	// calculated maximum depth for single digit offsets
	maxDentryDepth = (fetchArgMaxLength - dentryArgBaseOverhead) /
		dentryArgMinimumComponentOverhead
)

type dentryFetch struct {
	base      string
	key       string
	prefix    byte
	usedDepth int
}

type fileProbe struct {
	address   string
	fetchargs string
	filter    string
	dentries  []dentryFetch
}

type fileEventSource struct {
	name     string
	eventid  uint64
	groupid  int32
	counter  int32
	probes   []fileProbe
	dispatch func(*perf.Sample, expression.FieldValueMap)
	sensor   *Sensor
	lostType LostRecordType
}

func (fes *fileEventSource) register(monitor *FileMonitor, name string) error {
	monitor.Lock()
	defer monitor.Unlock()

	var err error
	if fes.counter == 0 {
		f := func(_ uint64, sample *perf.Sample, data expression.FieldValueMap) {
			fes.dispatch(sample, data)
		}
		fes.groupid, err = monitor.registerProbes(name, fes.probes, f,
			fes.lostRecordHandler)
	}

	fes.counter++
	return err
}

func (fes *fileEventSource) unregister(monitor *FileMonitor) {
	monitor.Lock()
	defer monitor.Unlock()

	fes.counter--
	if fes.counter == 0 && fes.groupid != 0 {
		if em := monitor.sensor.Monitor(); em != nil {
			em.UnregisterEventGroup(fes.groupid)
		}
		fes.groupid = 0
	}
}

func (fes *fileEventSource) lostRecordHandler(
	_ uint64,
	_ int32,
	sampleID perf.SampleID,
	count uint64,
) {
	glog.V(1).Infof("Lost %d %s related events\n", count, fes.name)

	var e LostRecordTelemetryEvent
	e.InitWithSampleID(fes.sensor, sampleID, count)
	e.Type = fes.lostType
	fes.sensor.DispatchEvent(fes.eventid, e, nil)

	atomic.AddUint64(&fes.sensor.Metrics.KernelSamplesLost, count)
}

// FileMonitor is a sensor service that monitors file activity on the host
// system, generating telemetry events for subscribers as requested.
type FileMonitor struct {
	sync.Mutex

	sensor *Sensor

	fileCreateEventSource          fileEventSource
	fileDeleteEventSource          fileEventSource
	fileLinkEventSource            fileEventSource
	fileSymlinkEventSource         fileEventSource
	fileOpenForModifyEventSource   fileEventSource
	fileCloseForModifyEventSource  fileEventSource
	fileModifyEventSource          fileEventSource
	fileRenameEventSource          fileEventSource
	fileAttributeChangeEventSource fileEventSource

	cachedMountPaths map[int32]string
}

func offset(target string, offset int) string {
	if offset < 0 {
		return fmt.Sprintf("%d(%s)", offset, target)
	}
	return fmt.Sprintf("+%d(%s)", offset, target)
}

// NewFileMonitor creates a new file monitor.
func NewFileMonitor(sensor *Sensor) *FileMonitor {
	monitor := &FileMonitor{
		sensor: sensor,
	}

	em := sensor.Monitor()

	// container_of(inode->i_sb->s_mounts, struct mount, mnt_instance)->mnt_id
	mountIDFromINodeInRDI := "mount=" + offset(
		offset(
			offset("%di", sensor.inodeSuperBlockOffset.Offset),
			sensor.superblockMountsOffset.Offset,
		),
		sensor.mountMntIDOffset.Offset-sensor.mountMntInstanceOffset.Offset,
	) + ":s32"
	mountIDFromINodeInRSI := "mount=" + offset(
		offset(
			offset("%si", sensor.inodeSuperBlockOffset.Offset),
			sensor.superblockMountsOffset.Offset,
		),
		sensor.mountMntIDOffset.Offset-sensor.mountMntInstanceOffset.Offset,
	) + ":s32"
	// *((const uint32_t *)path->mnt->mnt_sb->s_type->name)
	fstypeFromPathInRDI := "fstype=" + offset(
		offset(offset(offset(offset("%di", 0), 8), 40), 0),
		0,
	) + ":u32"
	// container_of(path->mnt, struct mount, mnt)->mnt_id
	mountIDFromPathInRDI := "mount=" + offset(
		offset("%di", 0),
		sensor.mountMntIDOffset.Offset-sensor.mountMntOffset.Offset,
	) + ":s32"
	// container_of(dentry->inode->i_sb->s_mounts, struct mount, mnt_instance)->mnt_id
	mountIDFromDentryInRDI := "mount=" + offset(
		offset(
			offset(
				offset("%di", 48),
				sensor.inodeSuperBlockOffset.Offset,
			),
			sensor.superblockMountsOffset.Offset,
		),
		sensor.mountMntIDOffset.Offset-sensor.mountMntInstanceOffset.Offset,
	) + ":s32"

	monitor.fileCreateEventSource = fileEventSource{
		name:     "file create",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileCreateEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileCreate,
		probes: []fileProbe{
			fileProbe{
				address:   "security_inode_create",
				fetchargs: "mode=%dx:s32 " + mountIDFromINodeInRDI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%si",
						key:    "filename",
						prefix: 'A',
					},
				},
			},
			fileProbe{
				address:   "vfs_mkdir",
				fetchargs: "mode=%dx:s32 " + mountIDFromINodeInRDI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%si",
						key:    "filename",
						prefix: 'A',
					},
				},
			},
			fileProbe{
				address:   "vfs_mknod",
				fetchargs: "mode=%dx:s32 " + mountIDFromINodeInRDI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%si",
						key:    "filename",
						prefix: 'A',
					},
				},
			},
		},
	}

	monitor.fileDeleteEventSource = fileEventSource{
		name:     "file delete",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileDeleteEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileDelete,
		probes: []fileProbe{
			fileProbe{
				address:   "vfs_rmdir",
				fetchargs: mountIDFromINodeInRDI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%si",
						key:    "filename",
						prefix: 'A',
					},
				},
			},
			fileProbe{
				address:   "vfs_unlink",
				fetchargs: mountIDFromINodeInRDI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%si",
						key:    "filename",
						prefix: 'A',
					},
				},
			},
		},
	}

	monitor.fileLinkEventSource = fileEventSource{
		name:     "file link",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileLinkEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileLink,
		probes: []fileProbe{
			fileProbe{
				address:   "vfs_link",
				fetchargs: mountIDFromINodeInRSI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%dx",
						key:    "target_file",
						prefix: 'A',
					},
					dentryFetch{
						base:   "%di",
						key:    "source_file",
						prefix: 'B',
					},
				},
			},
		},
	}

	monitor.fileSymlinkEventSource = fileEventSource{
		name:     "file symlink",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileSymlinkEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileSymlink,
		probes: []fileProbe{
			fileProbe{
				address:   "vfs_symlink",
				fetchargs: "source_file=+0(%dx):string " + mountIDFromINodeInRDI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%si",
						key:    "target_file",
						prefix: 'A',
					},
				},
			},
		},
	}

	monitor.fileOpenForModifyEventSource = fileEventSource{
		name:     "file open modify",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileOpenForModifyEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileOpenModify,
		probes: []fileProbe{
			fileProbe{
				address:   "may_open",
				fetchargs: "flag=%dx:s32 " + mountIDFromPathInRDI,
				filter:    "flag & 0x403", // O_RDWR|O_WRONLY|O_APPEND
				dentries: []dentryFetch{
					dentryFetch{
						base:   "+8(%di)", // path->dentry
						key:    "filename",
						prefix: 'A',
					},
				},
			},
		},
	}

	var dentryFetchBase, fetchargs string
	if sensor.fsnotifyParentHasPath {
		dentryFetchBase = "%si"
		fetchargs = fmt.Sprintf(
			"%s fd=%%si:u64 parent=+%d(%%si):u64 mask=%%dx:u32",
			mountIDFromPathInRDI, sensor.dentryStructParent.Offset)
	} else {
		dentryFetchBase = "%di"
		fetchargs = fmt.Sprintf(
			"fd=%%di:u64 parent=+%d(%%di):u64 mask=%%si:u32",
			sensor.dentryStructParent.Offset)
	}
	monitor.fileCloseForModifyEventSource = fileEventSource{
		name:     "file close modify",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileCloseForModifyEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileCloseModify,
		probes: []fileProbe{
			fileProbe{
				address:   "__fsnotify_parent",
				fetchargs: fetchargs,
				filter:    "mask == 8", // FS_CLOSE_WRITE = 0x00000008
				dentries: []dentryFetch{
					dentryFetch{
						base:   dentryFetchBase,
						key:    "filename",
						prefix: 'A',
					},
				},
			},
		},
	}

	monitor.fileRenameEventSource = fileEventSource{
		name:     "file rename",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileRenameEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileRename,
		probes: []fileProbe{
			fileProbe{
				address:   "vfs_rename",
				fetchargs: mountIDFromINodeInRDI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%cx",
						key:    "newname",
						prefix: 'A',
					},
					dentryFetch{
						base:   "%si",
						key:    "oldname",
						prefix: 'B',
					},
				},
			},
		},
	}

	var filter string
	if sensor.fsnotifyParentHasPath {
		dentryFetchBase = "%si"
		fetchargs = fmt.Sprintf(
			"%s %s fd=%%si:u64 parent=+%d(%%si):u64 mask=%%dx:u32",
			fstypeFromPathInRDI, mountIDFromPathInRDI,
			sensor.dentryStructParent.Offset)
		// 2 is FS_MODIFY; only valid combination of FS_MODIFY flags are
		// FS_MODIFY and FS_MODIFY | FS_ISDIR and we only would like to
		// monitor file writes
		// 1886807396 is devp of "devpts"
		// and 1953916260 is devt of "devtmpfs" in little-endian
		filter = "mask == 2 && fstype != 1886807396 && fstype != 1953916260"
	} else {
		dentryFetchBase = "%di"
		fetchargs = fmt.Sprintf(
			"fd=%%di:u64 parent=+%d(%%di):u64 mask=%%si:u32",
			sensor.dentryStructParent.Offset)
		// 2 is FS_MODIFY; only valid combination of FS_MODIFY flags are
		// FS_MODIFY and FS_MODIFY | FS_ISDIR and we only would like to
		// monitor file writes
		filter = "mask == 2"
	}
	monitor.fileModifyEventSource = fileEventSource{
		name:     "file modify",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileModifyEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileModify,
		probes: []fileProbe{
			fileProbe{
				address:   "__fsnotify_parent",
				fetchargs: fetchargs,
				filter:    filter,
				dentries: []dentryFetch{
					dentryFetch{
						base:   dentryFetchBase,
						key:    "filename",
						prefix: 'A',
					},
				},
			},
		},
	}

	monitor.fileAttributeChangeEventSource = fileEventSource{
		name:     "file attr change",
		eventid:  em.ReserveEventID(),
		dispatch: monitor.dispatchFileAttributeChangeEvent,
		sensor:   sensor,
		lostType: LostRecordTypeFileAttributeChange,
		probes: []fileProbe{
			fileProbe{
				address:   "security_inode_setattr",
				fetchargs: mountIDFromDentryInRDI,
				dentries: []dentryFetch{
					dentryFetch{
						base:   "%di", // dentry
						key:    "filename",
						prefix: 'A',
					},
				},
			},
		},
	}

	return monitor
}

func (dentry *dentryFetch) buildFetchargs(sensor *Sensor) string {
	dnameOffset := sensor.dentryStructName.Offset
	dparentOffset := sensor.dentryStructParent.Offset
	name := dentry.base
	args := make([]string, 0, maxDentryDepth)
	// Construct as many dereferences as will fit in fetchArgMaxLength bytes
	d := 1
	for {
		fetch := fmt.Sprintf("+0(+%d(%s)):string", dnameOffset, name)
		if len(fetch) > fetchArgMaxLength {
			// Exceeded the length, that's as far deep as we can fetch
			break
		}
		// Construct the full fetch string
		args = append(args, fmt.Sprintf("%c%02d=%s", dentry.prefix, d, fetch))
		name = fmt.Sprintf("+%d(%s)", dparentOffset, name)
		d++
	}
	dentry.usedDepth = d
	return strings.Join(args, " ")
}

func (dentry *dentryFetch) constructFilename(
	data expression.FieldValueMap,
) string {
	prefix := dentry.prefix
	dentryDepth := dentry.usedDepth
	root := dentryDepth
	var names [maxDentryDepth]string
	for k, v := range data {
		b := ([]byte)(k)
		if len(k) != 3 || b[0] != prefix {
			continue
		}

		i := int(((b[1] - '0') * 10) + b[2] - '0')
		name := v.(string)
		if name == "/" || name == "" {
			if i < root {
				root = i
			}
			continue
		}
		names[dentryDepth-i] = name
	}

	var filename string
	if root == dentryDepth {
		filename = "../" + strings.Join(names[:dentryDepth], "/")
	} else {
		filename = strings.Join(names[dentryDepth-root:dentryDepth], "/")
	}

	return filename
}

func (monitor *FileMonitor) registerProbes(
	name string,
	probes []fileProbe,
	handlerFunc func(uint64, *perf.Sample, expression.FieldValueMap),
	lostFunc perf.EventMonitorLostRecordFn,
) (int32, error) {
	em := monitor.sensor.Monitor()
	groupid, err := em.RegisterEventGroup(name, lostFunc)
	if err != nil {
		err = fmt.Errorf("Could not create event group: %v", err)
		return 0, err
	}

	for _, probe := range probes {
		args := make([]string, 0, 3)
		if probe.fetchargs != "" {
			args = append(args, probe.fetchargs)
		}

		// Append the dentry fetch args
		for i := range probe.dentries {
			// Construct a prefix for the generated dentry args
			args = append(args, probe.dentries[i].buildFetchargs(monitor.sensor))
		}

		// Need an anonymous wrapper function so that the closure capture gets
		// the current probe instead of the last probe
		f := (func(probe fileProbe) func(eventid uint64, sample *perf.Sample) {
			return func(eventid uint64, sample *perf.Sample) {
				var data expression.FieldValueMap
				data, err = sample.DecodeRawData()
				if err != nil {
					return
				}
				for _, dentry := range probe.dentries {
					data[dentry.key] = dentry.constructFilename(data)
				}
				handlerFunc(eventid, sample, data)
			}
		})(probe)

		var opts = []perf.RegisterEventOption{
			perf.WithEventDisabled(),
		}
		if probe.filter != "" {
			opts = append(opts, perf.WithFilter(probe.filter))
		}
		_, err = monitor.sensor.RegisterKprobe(probe.address, false,
			strings.Join(args, " "), f, groupid, opts...)
		if err != nil {
			err = fmt.Errorf("Could not register kprobe from file monitor %s: %v (%v)",
				probe.address, err, strings.Join(args, " "))
			return 0, err
		}
	}

	em.EnableGroup(groupid)
	return groupid, nil
}

func (monitor *FileMonitor) readMountedPath(
	data expression.FieldValueMap,
	pathKey string,
) string {
	// Cache the mount points
	// TODO: invalidate this cache when a filesystem is mounted
	cachedMountPaths := monitor.cachedMountPaths
	if cachedMountPaths == nil {
		cachedMountPaths = make(map[int32]string)
		for _, mount := range monitor.sensor.ProcFS.Mounts() {
			// Don't add / to the map, it is the fallback
			if mount.MountPoint != "/" {
				cachedMountPaths[int32(mount.MountID)] = mount.MountPoint
			}
		}
		monitor.cachedMountPaths = cachedMountPaths
	}

	// Retrieve and apply the mountpoint if found
	path := data[pathKey].(string)
	mount := data["mount"]
	if mount != nil {
		if mountPoint, found := cachedMountPaths[mount.(int32)]; found {
			path = filepath.Join(mountPoint, path)
		}
	}

	return path
}

func (monitor *FileMonitor) dispatchFileCreateEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	var e FileCreateTelemetryEvent
	if e.InitWithSample(monitor.sensor, sample) {
		e.Filename = monitor.readMountedPath(data, "filename")
		e.Mode = data["mode"].(int32)
		monitor.sensor.DispatchEvent(
			monitor.fileCreateEventSource.eventid, e, data)
	}
}

func (monitor *FileMonitor) dispatchFileDeleteEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	var e FileDeleteTelemetryEvent
	if e.InitWithSample(monitor.sensor, sample) {
		e.Filename = monitor.readMountedPath(data, "filename")
		monitor.sensor.DispatchEvent(
			monitor.fileDeleteEventSource.eventid, e, data)
	}
}

func (monitor *FileMonitor) dispatchFileLinkEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	var e FileLinkTelemetryEvent
	if e.InitWithSample(monitor.sensor, sample) {
		e.SourceFile = monitor.readMountedPath(data, "source_file")
		e.TargetFile = monitor.readMountedPath(data, "target_file")
		monitor.sensor.DispatchEvent(
			monitor.fileLinkEventSource.eventid, e, data)
	}
}

func (monitor *FileMonitor) dispatchFileSymlinkEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	var e FileLinkTelemetryEvent
	if e.InitWithSample(monitor.sensor, sample) {
		e.SourceFile = monitor.readMountedPath(data, "source_file")
		e.TargetFile = data["target_file"].(string)
		e.Symlink = true
		monitor.sensor.DispatchEvent(
			monitor.fileSymlinkEventSource.eventid, e, data)
	}
}

func (monitor *FileMonitor) dispatchFileModifyEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	// pseudo-files have self as parent; would like to be able to filter in-kernel
	if data["fd"].(uint64) != data["parent"].(uint64) {
		var e FileModifyTelemetryEvent
		if e.InitWithSample(monitor.sensor, sample) {
			e.Filename = monitor.readMountedPath(data, "filename")
			monitor.sensor.DispatchEvent(
				monitor.fileModifyEventSource.eventid, e, data)
		}
	}
}

func (monitor *FileMonitor) dispatchFileRenameEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	var e FileRenameTelemetryEvent
	if e.InitWithSample(monitor.sensor, sample) {
		e.Oldname = monitor.readMountedPath(data, "oldname")
		e.Newname = monitor.readMountedPath(data, "newname")
		monitor.sensor.DispatchEvent(
			monitor.fileRenameEventSource.eventid, e, data)
	}
}

func (s *Subscription) handleDoSysOpen(eventid uint64, sample *perf.Sample) {
	var e FileOpenTelemetryEvent
	if e.InitWithSample(s.sensor, sample) {
		e.Filename, _ = sample.GetString("filename")
		e.Flags, _ = sample.GetSignedInt32("flags")
		e.Mode, _ = sample.GetSignedInt32("mode")
		s.DispatchEvent(eventid, e, nil)
	}
}

func (s *Subscription) registerFileMonitorEventFilter(
	monitor *FileMonitor,
	source *fileEventSource,
	filter *expression.Expression,
	name string,
) {
	if err := source.register(monitor, name); err != nil {
		s.logStatus(fmt.Sprintf("%s system error: %v", name, err))
		return
	}
	es, err := s.addEventSink(source.eventid, filter)
	if err != nil {
		s.logStatus(
			fmt.Sprintf("Invalid %s filter expression: %v",
				strings.ToLower(name), err))
	} else {
		es.unregister = func(_ *eventSink) {
			source.unregister(monitor)
		}
	}
}

func (monitor *FileMonitor) dispatchFileOpenForModifyEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	var e FileOpenForModifyTelemetryEvent
	if e.InitWithSample(monitor.sensor, sample) {
		e.Filename = monitor.readMountedPath(data, "filename")
		monitor.sensor.DispatchEvent(
			monitor.fileOpenForModifyEventSource.eventid, e, data)
	}
}

func (monitor *FileMonitor) dispatchFileCloseForModifyEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	// pseudo-files have self as parent; would like to be able to filter in-kernel
	if data["fd"].(uint64) != data["parent"].(uint64) {
		var e FileCloseForModifyTelemetryEvent
		if e.InitWithSample(monitor.sensor, sample) {
			e.Filename = monitor.readMountedPath(data, "filename")
			monitor.sensor.DispatchEvent(
				monitor.fileCloseForModifyEventSource.eventid, e, data)
		}
	}
}

func (monitor *FileMonitor) dispatchFileAttributeChangeEvent(
	sample *perf.Sample,
	data expression.FieldValueMap,
) {
	var e FileAttributeChangeTelemetryEvent
	if e.InitWithSample(monitor.sensor, sample) {
		e.Filename = monitor.readMountedPath(data, "filename")
		monitor.sensor.DispatchEvent(
			monitor.fileAttributeChangeEventSource.eventid, e, data)
	}
}

// RegisterFileCreateEventFilter registers a file create event filter with a
// subscription.
func (s *Subscription) RegisterFileCreateEventFilter(filter *expression.Expression) {
	monitor := s.sensor.FileMonitor
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileCreateEventSource, filter, "File Create")
}

// RegisterFileDeleteEventFilter registers a file delete event filter with a
// subscription.
func (s *Subscription) RegisterFileDeleteEventFilter(filter *expression.Expression) {
	monitor := s.sensor.FileMonitor
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileDeleteEventSource, filter, "File Delete")
}

// RegisterFileLinkEventFilter registers both a file link and file symlink event
// filter with a subscription.
func (s *Subscription) RegisterFileLinkEventFilter(filter *expression.Expression) {
	monitor := s.sensor.FileMonitor
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileLinkEventSource, filter, "File Link")
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileSymlinkEventSource, filter, "File Symlink")
}

// RegisterFileOpenForModifyEventFilter registers a file open for modify event filter with a
// subscription.
func (s *Subscription) RegisterFileOpenForModifyEventFilter(filter *expression.Expression) {
	monitor := s.sensor.FileMonitor
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileOpenForModifyEventSource, filter, "File Open For Modify")
}

// RegisterFileCloseForModifyEventFilter registers a file open for modify event filter with a
// subscription.
func (s *Subscription) RegisterFileCloseForModifyEventFilter(filter *expression.Expression) {
	monitor := s.sensor.FileMonitor
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileCloseForModifyEventSource, filter, "File Close For Modify")
}

// RegisterFileModifyEventFilter registers a file modify event filter with a
// subscription.
func (s *Subscription) RegisterFileModifyEventFilter(filter *expression.Expression) {
	monitor := s.sensor.FileMonitor
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileModifyEventSource, filter, "File Modify")
}

// RegisterFileOpenEventFilter registers a file open event filter with a
// subscription.
func (s *Subscription) RegisterFileOpenEventFilter(filter *expression.Expression) {
	s.registerKprobe(fsDoSysOpenKprobeAddress, false,
		fsDoSysOpenKprobeFetchargs, s.handleDoSysOpen,
		filter, false)
}

// RegisterFileRenameEventFilter registers a filer rename event filter with a
// subscription.
func (s *Subscription) RegisterFileRenameEventFilter(filter *expression.Expression) {
	monitor := s.sensor.FileMonitor
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileRenameEventSource, filter, "File Rename")
}

// RegisterFileAttributeChangeEventFilter registers a file attribute change
// event filter with a subscription.
func (s *Subscription) RegisterFileAttributeChangeEventFilter(filter *expression.Expression) {
	monitor := s.sensor.FileMonitor
	s.registerFileMonitorEventFilter(monitor,
		&monitor.fileAttributeChangeEventSource, filter, "File Attribute Change")
}
